#------------------------------------------------------------------------------
# Program Name: A1.1.UN_pop_WB_extension.R
# Author: Linh Vu
# Date Last Updated: August 18, 2015
# Program Purpose: Produce input population data for CEDS emissions system from
#                  United Nations data, and World Bank (WB) data where UN data are
#                  unavailable. Output are 1950-2100 population.
# Input Files: IEA_ctry.csv; UN_pop_raw.csv OR supplied URL for UN population data
# Output Files: A.UN_pop_master.csv
# Notes: 1. Population for dissolved countries (scg and csk) are generated by 
#           summing member countries' population (keeping population for both separate 
#           and combined countries)
#        2. UN population is available 1950-2100; WB population is available 1960-2014. 
#           Where WB is used, population for remaining UN years are extrapolated using 
#           a proxy country's UN population growth rate (currently only using WB for 
#           Kosovo, with Serbia as proxy)
# TODO: Generate population for ant (Netherlands Antilles)
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# 0. Read in global settings and headers

# Before we can load headers we need some paths defined. They may be provided by
#   a system environment variable or may have already been set in the workspace.
    dirs <- paste0( unlist( strsplit( getwd(), c( '/', '\\' ), fixed = T ) ), '/' )
    for ( i in 1:length( dirs ) ) {
      setwd( paste( dirs[ 1:( length( dirs ) + 1 - i ) ], collapse = '' ) )
      wd <- grep( 'CEDS/input', list.dirs(), value = T )
      if ( length( wd ) > 0 ) {
        setwd( wd[ 1 ] )
        break
      }
    }
    PARAM_DIR <- "../code/parameters/"
    
# Call standard script header function to read in universal header files - 
# provide logging, file support, and system functions - and start the script log.
    headers <- c( "data_functions.R", "analysis_functions.R" ) # Additional function files required.
    log_msg <- "Produce population data for CEDS from UN data" # First message to be printed to the log
    script_name <- "A1.1.UN_pop_WB_extension.R"
    
    source( paste0( PARAM_DIR, "header.R" ) )
    initialize( script_name, log_msg, headers )
    
# ------------------------------------------------------------------------------
# 1. Read in files and do preliminary setup
# Download required packages if necessary
    mirror <- "http://watson.nci.nih.gov/cran_mirror/"

    if ( !require( "XLConnect", character.only = T ) ){
      install.packages( "XLConnect", dep = T, repos = mirror )
    }
    if ( !require( "FAOSTAT", character.only = T ) ){
      install.packages( "FAOSTAT", dep = T, repos = mirror )
    }
    library( XLConnect )
    library( FAOSTAT )
   
# Read in data
    # When new UN population data are released, update `url` and uncomment the following 2
    # lines to download the new dataset to local directory
#     url <- "http://esa.un.org/unpd/wpp/Excel-Data/EXCEL_FILES/1_Population/WPP2012_POP_F01_1_TOTAL_POPULATION_BOTH_SEXES.XLS"
#     download.file( url, destfile = paste0( getwd(), "/general/UN_pop_raw.xlsx" ) ) 
    
    UN_pop_raw <- loadWorkbook( paste0( getwd(), "/general/UN_pop_raw.xlsx" ) )
    WB_pop <- getWDI( indicator = "SP.POP.TOTL", name = "pop")  # WB population data, pulled from WDI API
    #FAO_pop <- getFAO( name = "pop", domainCode = "OA", elementCode = 511, itemCode = 3010 )
    CEDS_ctry <- readData( "MAPPINGS", "IEA_ctry", meta = F )

# ------------------------------------------------------------------------------
# 2. Clean up input 

# Prepare UN population
    # readUNSheet(): reads individual UN sheet, reformats and returns results in a df
    readUNSheet <- function( file, sheet ) {
      newfile <-  # skip heading and drop irrelevant columns 
        readWorksheet( file, sheet, startRow = 17, drop = c( "Index", "Notes" ), check.names = F )
      newfile <-  # translate from UN code to iso3 
        translateCountryCode( newfile, "UN_CODE", "ISO3_WB_CODE", "Country code" )
      names( newfile )[ 1:4 ] <- c( "UN_code", "iso", "scenario", "country" )
      newfile$iso <- tolower( newfile$iso )  # change to lowercase ISO
      return( newfile )
    }
 
    # Read UN data into one data frame
    UN_sheets <- getSheets( UN_pop_raw )  # get sheet names
    UN_sheets <- as.list( UN_sheets[ - length( UN_sheets ) ] )  # remove final sheet ('Notes'); result is list of pop scenarios
    UN_pop <- lapply( UN_sheets, readUNSheet, file = UN_pop_raw )
    UN_pop <- do.call( rbind.fill, UN_pop )
    
    # Reshape and fix inconsistent/incomplete codes
    UN_pop <- melt( UN_pop, id = c( "UN_code", "iso", "scenario", "country" ), variable_name = "year", na.rm = T )
    names( UN_pop )[ names( UN_pop ) == "value" ] <- "pop"
    UN_pop$year <- as.numeric( as.character( UN_pop$year ) )  # convert from factor
    UN_pop$country[ UN_pop$UN_code == "158" ] <- "Taiwan"  # pull Taiwan from "Other non-specified areas"
    UN_pop$iso[ UN_pop$UN_code == 156 ] <- "chn"  # add ISO for China
    UN_pop$iso[ UN_pop$iso == "zar" ] <- "cod"  # change ISO of Democratic Republic of Congo
    UN_pop$iso[ UN_pop$iso == "tmp" ] <- "tls"  # change ISO of Timor-Leste
    UN_pop$iso[ UN_pop$iso == "rom" ] <- "rou"  # change ISO of Romania
    UN_pop <- filter( UN_pop, UN_code < 900 )  # skip aggregated regions
    UN_pop <- arrange( UN_pop, scenario, iso, year )
    
# Prepare WB population        
    WB_pop <-  # translate from iso2 to iso3 
      translateCountryCode( WB_pop, "ISO2_WB_CODE", "ISO3_WB_CODE", "ISO2_WB_CODE" ) %>%
      select( -ISO2_WB_CODE )  # drop ISO2
    names( WB_pop ) <- c( "iso", "country", "year", "pop" )
    WB_pop$iso <- tolower( WB_pop$iso )  # convert to lowercase ISO
    WB_pop$pop <- WB_pop$pop / 1000  # convert pop units to thous. people
    WB_pop <- arrange( WB_pop, iso, year )

# Define useful values
    WB_years <- sort( unique( WB_pop$year ) )
    #UN_years <- sort( unique( as.numeric( as.character( UN_pop$year ) ) ) )
    pop_header <- names( UN_pop )
    
# ------------------------------------------------------------------------------
# 3. Produce population series from UN and WB data
# Diagnostics: What countries in CEDS are missing from UN pop?
    in_CEDS_not_in_UN <- setdiff( unique( CEDS_ctry$iso ), unique( UN_pop$iso) )
    in_CEDS_not_in_UN <- in_CEDS_not_in_UN[ !is.na( in_CEDS_not_in_UN ) & in_CEDS_not_in_UN %!in% "iso" ]
    # scg (Serbia and Montenegro), srb (Kosovo),
    # ant (Netherlands Antilles): dissolved in 2010; now merged back to Netherlands
    if ( length( in_CEDS_not_in_UN ) > 0 ) {
      warning( "The following CEDS countries do not have UN data: \n")
      for (i in 1:length( in_CEDS_not_in_UN ) ) {
        warning( paste0( in_CEDS_not_in_UN[[i]], ": ", 
                         unique( CEDS_ctry$IEA_ctry[ CEDS_ctry$iso %in% in_CEDS_not_in_UN[[i]] ] ), "; " ) )
      }
    }

# Define functions to handle population generation
    # pop_list: list of population df, used for generating final population data. 
    # Population-geneartion functions (sumPop(), extendIndivScenario(), extendPop())
    # will append results as new elements of pop_list.
    # All pop_list elements should have the same variable list, hence the need for
    # function completeID() below.
    pop_list <- list( UN_pop )
    
    # completeID(): takes in single country population and adds ID columns 
    # (UN_code, iso, country) where missing. Will be called by population-generation
    # functions: sumPop(), extendIndivScenario() and extendPop()
    completeID <- function( df, UN_code = "", iso = "", country = "" ){
      if ( "UN_code" %!in% names( df ) ){
        df$UN_code <- UN_code
      }
      if ( "iso" %!in% names( df ) ){
        df$iso <- iso
      }
      if ( "country" %!in% names( df ) ){
        df$country <- country
      }
      return( df )
    }
    
    # sumPop(): looks in df for countries listed in vector_of_iso and returns sum
    # of their population; used for handling dissolved countries. Results are appended
    # to pop_list
    sumPop <- function( df, vector_of_iso, UN_code = "", iso = "", country = "" ){
      # check that df has population for all member countries listed in vector_of_iso
      if ( length( unique( df$iso[ df$iso %in% vector_of_iso ] ) ) == length( vector_of_iso ) ) {
        new_df <- filter( df, iso %in%  vector_of_iso ) %>%
          group_by( scenario, year ) %>%
          summarise( pop = sum( pop ) )
        new_df <- completeID( new_df, UN_code, iso, country )
        pop_list[[ length( pop_list ) + 1 ]] <<- new_df  # append to pop_list
        # note that list cannot be appended with c() when using df
        warnings( cat( "Population for ", iso, " (now dissolved) is generated by summing member countries: ",
                         unique( df$iso[ df$iso %in% vector_of_iso ] ) ) )
        return( new_df )
      } else {
        warning( paste0( "Population for ", iso, " cannot be generated" ) )
      }
    }
    
    # extendIndivScenario(): takes incomplete population time series for ONE scenario, extends 
    # population to all years, returns the completed population time series
    # pop1: incomplete population time series; assumed to cover a continuous subset of all 
    #       available years (e.g. 1960-2014 is a continuous subset of 1950-2100)
    # pop2: a proxy (complete) population time series; where pop1 is missing, extend using pop1's
    #       nearest data year and pop2's corresponding growth rate (see example below)
    # first_data_year: first year where pop1 is available
    # last_data_year: last year where pop1 is available
    # EXAMPLE: Say pop1 is available 1960-2014 and pop2 is available 1950-2100, so first_data_year
    # is 1960 and last_data_year is 2014. Then pop1 will be extended to 1950-2100 as follows:
    #   pop1[1959] = pop1[1960] / pop2_growth[1959 to 1960]
    #   pop1[1958] = pop1[1959] / pop2_growth[1958 to 1959]
    #              = pop1[1960] / ( pop2_growth[1958 to 1959] * pop2_growth[1959 to 1960] )
    #   pop1[1950] = pop1[1960] / ( pop2_growth[1950 to 1951] * ... * pop2_growth[1959 to 1960] )
    #   pop1[2100] = pop1[2014] * ( pop2_growth[2014 to 2015] * ... * pop2_growth[2099 to 2100] )
    extendIndivScenario <- function( df, pop1, pop2, first_data_yr, last_data_yr, 
                                     UN_code = "", iso = "", country = "" ){
      df <- arrange( df, year )
      df$growth <- df[, pop2 ] / lag( df[, pop2 ] )  # calculate growth of pop2
      for ( i_year in df$year ){
        if ( i_year < first_data_yr ){
          df[ df$year == i_year, pop1 ] <- df[ df$year == first_data_yr, pop1 ] /
            prod( df$growth[ df$year <= first_data_yr & df$year > i_year ] )
        }
        if ( i_year > last_data_yr ){
          df[ df$year == i_year, pop1 ] <- df[ df$year == last_data_yr, pop1 ] *
            prod( df$growth[ df$year > last_data_yr & df$year <= i_year ] )
        }
      }
      names( df )[ names( df ) == pop1 ] <- "pop"
      df <- df[ names( df ) %in% pop_header ]
      df <- completeID( df, UN_code, iso, country )
      return( df )
    }
    
    # extendPop(): operates split-apply-combine of extendIndivScenario() by scenario.
    # Results are appended to pop_list.
    extendPop <- function( df, pop1, pop2, first_data_yr, last_data_yr, 
                           UN_code = "", iso = "", country = "" ){
      new_df <- ddply( df, .(scenario), function(x){
        extendIndivScenario( x, pop1, pop2, first_data_yr, last_data_yr, UN_code, iso, country )
      } )
      pop_list[[ length( pop_list ) + 1 ]] <<- new_df  # append to pop_list 
      warning( paste0( pop1, " is only available ", 
                       first_data_yr, "-", last_data_yr, 
                       ". Remaining years are estimated using ", pop2, " growth rate." ) )
      return( new_df )
    } 
    
# For Kosovo (detached from Serbia in 2008), use WB Kosovo population (1960-2014)
# and Serbia's pop growth to extend the remaining years (1950-1959, 2015-2100)
    # Extract Kosovo from WB population, Serbia from UN population, and merge into one df
    kosovo <- filter( WB_pop, country %in% "Kosovo" )
    kosovo <- select( kosovo, year, pop )
    names( kosovo ) <- c( "year", "kosovo_pop" )
    serbia <- filter( UN_pop, country == "Serbia" )
    serbia <- select( serbia, scenario, year, pop )
    names( serbia ) <- c( "scenario", "year", "serbia_pop" )
    serbia_kosovo <- merge( serbia, kosovo, by = "year", all = T )
    serbia_kosovo <- arrange( serbia_kosovo, scenario, year )

    # Extend Kosovo population using Serbia's growth. Results are added to pop_list for 
    # later binding. The object kosovo_new itself is not used.
    kosovo_new <- extendPop( serbia_kosovo, pop1 = "kosovo_pop", pop2 = "serbia_pop", 
                             first_data_yr = min( WB_years ), last_data_yr = max( WB_years ),
                             country = "Kosovo", iso = "srb (Kosovo)" )

# For csk (dissolved in 1993 into cze and slk) and scg (dissolved in 2006 into srb and mne),
# add population of member countries before dissolution. Results are added to pop_list for later
# binding. The objects csk and scg themselves are not used.
    # csk <- sumPop( UN_pop, c( "cze", "slk" ), UN_code = 200, iso = "csk", country = "Czechoslovakia" )
    scg <- sumPop( UN_pop, c( "mne", "srb" ), UN_code = 891, iso = "scg", country = "Serbia and Montenegro" )
    
# Create master population data (with projections for now-extinct countries)
    pop_master <- ldply( pop_list, rbind ) %>%
      arrange( scenario, iso, year )

# ------------------------------------------------------------------------------
# 4. Write output
    writeData( pop_master, "MED_OUT", "A.UN_pop_master" )
    
# Every script should finish with this line
    logStop()
    
# END