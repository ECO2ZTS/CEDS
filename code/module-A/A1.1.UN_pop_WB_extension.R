#------------------------------------------------------------------------------
# Program Name: A1.1.UN_pop_WB_extension.R
# Author: Linh Vu, Rachel Hoesly
# Date Last Updated: 18 December 2015
# Program Purpose: Produce input population data for CEDS emissions system from
#                  United Nations data, and World Bank (WB) data where UN data are
#                  unavailable. Output are 1950-2100 population and urban population
#                  share.
# Input Files: WPP2015_POP_F01_1_TOTAL_POPULATION_BOTH_SEXES.XLS;
#              WUP2014-F21-Proportion_Urban_Annual.xls; 
#              WB_SP.POP.TOTL.csv; WB_SP.URB.TOTL; Master_Country_List.csv
# Output Files: A.UN_pop_master.csv
# Notes: 1. UN population data are downloaded from:
#           -- Total population: http://esa.un.org/unpd/wpp/DVD/
#           -- Urban population share: http://esa.un.org/unpd/wup/CD-ROM/
#           WB population and urban population share data are pulled from the WDI
#           API, using the R package FAOSTAT.
#        2. UN has population data for 1950-2100, urban share data for 1950-2050;
#           WB has population and urban share data for 1960-2014. Where no UN data 
#           (population or urban share) are available, WB data are used. 
#           -- If WB population is used, extrapolate to all UN years using a proxy 
#              country's UN population growth rate, and use WB urban share or
#              assume proxy country's UN urban share if WB urban share unavailable.
#           -- Currently use WB data for: Kosovo's population (Serbia as proxy, 
#              assume Serbias UN urban share).
#        3. Population for dissolved countries are generated by summing member 
#           countries' population. Population for both separate and combined 
#           countries are kept.
#           -- Currently generate population for Serbia and Montenegro (scg) by
#              summing Serbia and Montenegro population
#        4. Urban share are linearly extrapolated to all UN population years, using
#           last available data year and growth rate in the two edge years.
# TODO: Generate population for ant (Netherlands Antilles)
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# 0. Read in global settings and headers

# Before we can load headers we need some paths defined. They may be provided by
#   a system environment variable or may have already been set in the workspace.
    dirs <- paste0( unlist( strsplit( getwd(), c( '/', '\\' ), fixed = T ) ), '/' )
    for ( i in 1:length( dirs ) ) {
      setwd( paste( dirs[ 1:( length( dirs ) + 1 - i ) ], collapse = '' ) )
      wd <- grep( 'CEDS/input', list.dirs(), value = T )
      if ( length( wd ) > 0 ) {
        setwd( wd[ 1 ] )
        break
      }
    }
    PARAM_DIR <- "../code/parameters/"
    
# Call standard script header function to read in universal header files - 
# provide logging, file support, and system functions - and start the script log.
    headers <- c( "IO_functions.R","data_functions.R", "analysis_functions.R" )
    log_msg <- "Produce population data for CEDS from UN data"
    script_name <- "A1.1.UN_pop_WB_extension.R"
    
    source( paste0( PARAM_DIR, "header.R" ) )
    initialize( script_name, log_msg, headers )
    
# ------------------------------------------------------------------------------
# 1. Read in files and do preliminary setup
# Download required packages if necessary
    loadPackage( "FAOSTAT" )

# Read UN population and urban population data
    UN_pop_raw <- readData( "GEN_IN", "WPP2015_POP_F01_1_TOTAL_POPULATION_BOTH_SEXES",
                            ".xlsx", sheet_selection = "ALL", skip_rows = 16, meta = F )
    UN_urban_share_raw <- readData( "GEN_IN", "WUP2014-F21-Proportion_Urban_Annual",
                                    ".xlsx", sheet_selection = "ANNUAL DATA",
                                    skip_rows = 16, meta = F )
    
# Read WB population and urban population data, either by pulling from the WDI API 
#   or reading from directory (currently selected)
#     WB_pop_raw <- getWDI( indicator = "SP.POP.TOTL", name = "pop" ) %>% 
#       filter( !is.na( pop ) )  # drop non-data rows
#     WB_urban_pop_raw <- getWDI( indicator = "SP.URB.TOTL", name = "urban_pop" ) %>% 
#       filter( !is.na( urban_pop ) )  # drop non-data rows
    WB_pop_raw <- readData( "GEN_IN", "WB_SP.POP.TOTL", meta = F )
    WB_urban_pop_raw <- readData( "GEN_IN", "WB_SP.URB.TOTL", meta = F )

# Read CEDS country list
    MCL <- readData( "MAPPINGS", "Master_Country_List", meta = F )

# Define standardized UN scenario names (check against Excel input)
    UN_scenarios_std <- c( "Estimates", "Medium fertility", "High fertility", 
                           "Low fertility", "Constant fertility", "Instant-replacement",
                           "Zero-migration", "Constant-mortality", "No change" )
    
# ------------------------------------------------------------------------------
# 2. Clean up UN and WB population input 
# Prepare UN population
    # Read all population scenarios into one df
    UN_pop_raw <- lapply( seq_along( UN_pop_raw[ -1 ] ), function( i ){
      out <- translateCountryCode( UN_pop_raw[[ i ]], 
                                   "UN_CODE", "ISO3_WB_CODE", "Country code" )
      out <- out[ -c( 3, 4, 6 ) ]
      names( out )[ 1:3 ] <- c( "UN_code", "iso", "country" )
      out$scenario <- UN_scenarios_std[[ i ]]
      out <- melt( out, id = c( "UN_code", "iso", "scenario", "country" ), 
                   variable_name = "year", na.rm = T )
      names( out )[ names( out ) == "value" ] <- "pop"
      return( out )
    } )
    UN_pop_raw <- do.call( rbind, UN_pop_raw )
    UN_pop_raw$year <- as.numeric( as.character( UN_pop_raw$year ) )
    
    # Read and format urban population share
    UN_urban_share_raw <- translateCountryCode( UN_urban_share_raw, "UN_CODE",
                                              "ISO3_WB_CODE", "Country Code" )
    UN_urban_share_raw <- UN_urban_share_raw[ -c( 3:5 ) ]
    names( UN_urban_share_raw )[ 1:2 ] <- c( "UN_code", "iso" )
    UN_urban_share_raw <- melt( UN_urban_share_raw, id = c( "UN_code", "iso" ), 
                             variable_name = "year", na.rm = T )
    names( UN_urban_share_raw )[ names( UN_urban_share_raw ) == "value" ] <- "urban_share"
    UN_urban_share_raw$urban_share <- UN_urban_share_raw$urban_share / 100  # percent to decimal
    UN_urban_share_raw$year <- as.numeric( as.character( UN_urban_share_raw$year ) )

    # Check that all countries with UN population have UN urban share
    no_UN_urban <- setdiff( UN_pop_raw$iso, UN_urban_share_raw$iso )  # should be empty
    
    # Merge total population and urban share in one df and compute urban population
    UN_pop <- merge( UN_pop_raw, UN_urban_share_raw, all.x = T ) %>%
      mutate( urban_pop = pop * urban_share )
    
    # Fix missing/outdated ISO codes
    UN_pop$iso <- tolower( UN_pop$iso )  # lowercase ISO
    UN_pop$country[ UN_pop$UN_code == "158" ] <- "Taiwan"  # pull Taiwan from "Other non-specified areas"
    UN_pop$iso[ UN_pop$UN_code == 156 ] <- "chn"  # add ISO for China
    UN_pop$iso[ UN_pop$iso == "zar" ] <- "cod"  # update ISO of Democratic Republic of Congo
    UN_pop$iso[ UN_pop$iso == "tmp" ] <- "tls"  # update ISO of Timor-Leste
    UN_pop$iso[ UN_pop$iso == "rom" ] <- "rou"  # update ISO of Romania
    UN_pop$iso[ UN_pop$iso == "ado" ] <- "and"  # update ISO of Andorra
    UN_pop$iso[ UN_pop$iso == "imy" ] <- "imn"  # update ISO of Isle of Man
    UN_pop <- filter( UN_pop, UN_code < 900 )  # skip aggregated regions
    UN_pop <- arrange( UN_pop, scenario, iso, year )
    
# Prepare WB population     
    # Merge WB pop and urban pop into one df and reformat
    WB_pop <- merge( WB_pop_raw, WB_urban_pop_raw, all.x = T ) %>%
      translateCountryCode( "ISO2_WB_CODE", "ISO3_WB_CODE", "ISO2_WB_CODE" ) %>% 
      select( -ISO2_WB_CODE ) %>% unique()  # ISO2 to ISO3
    names( WB_pop ) <- c( "iso", "country", "year", "pop", "urban_pop" )
    WB_pop$iso <- tolower( WB_pop$iso )
    WB_pop$pop <- WB_pop$pop / 1000  # convert pop units to thous. people
    WB_pop$urban_pop <- WB_pop$urban_pop / 1000
    WB_pop <- mutate( WB_pop, urban_share = urban_pop / pop )  # compute urban share 
    WB_pop <- arrange( WB_pop, iso, year )

# Define useful values
    WB_pop_years <- sort( unique( WB_pop_raw$Year ) )
    # WB_urban_years <- sort( unique( WB_urban_pop_raw$Year ))
    UN_pop_years <- sort( unique( UN_pop_raw$year ) )
    UN_urban_years <- sort( unique( UN_urban_share_raw$year ) )

# ------------------------------------------------------------------------------
# 3. Produce population series from UN and WB data
# Diagnostics: What countries in CEDS are missing from UN pop?
    in_CEDS_not_in_UN <- setdiff( unique( MCL$iso ), unique( UN_pop$iso) )
    in_CEDS_not_in_UN <- in_CEDS_not_in_UN[ !is.na( in_CEDS_not_in_UN ) & 
                                              in_CEDS_not_in_UN != "iso" ]
    # scg (Serbia and Montenegro), srb (Kosovo),
    # ant (Netherlands Antilles): dissolved in 2010; now merged back to Netherlands
    if ( length( in_CEDS_not_in_UN ) > 0 ) {
      warning( "The following CEDS countries do not have UN data: \n")
      for (i in 1:length( in_CEDS_not_in_UN ) ) {
        warning( paste0( in_CEDS_not_in_UN[[i]], ": ", 
          MCL$Country_Name[ match( in_CEDS_not_in_UN[[ i ]], MCL$iso ) ] ) ) 
      }
    }

# Define functions to handle population generation
    # pop_list: list of population df, used for generating final population data. 
    # Population-geneartion functions (sumPop(), extendIndivScenario(), extendPop())
    # will append results as new elements of pop_list.
    # All pop_list elements should have the same variable list, hence the need for
    # function completeID() below.
    pop_list <- list( UN_pop )
    
    # completeID(): takes in single country df and adds ID columns (UN_code, iso, 
    # country);called by population-generation functions: sumPop(), extendIndivScenario(),
    # extendPop()
    completeID <- function( df, UN_code = NA, iso = NA, country = NA ){
      return( mutate( df, UN_code = UN_code, iso = iso, country = country ) )
    }
    
    # sumPop(): looks in df for countries listed in vector_of_iso and returns sum
    # of their population; used for handling dissolved countries. Results are appended
    # to pop_list.
    sumPop <- function( df, vector_of_iso, UN_code = NA, iso = NA, country = NA ){
      # check that df has population for all member countries, listed in vector_of_iso
      if ( length( unique( df$iso[ df$iso %in% vector_of_iso ] ) ) == length( vector_of_iso ) ) {
        out <- filter( df, iso %in% vector_of_iso ) %>%
          group_by( scenario, year ) %>%
          summarise( pop = sum( pop ), urban_pop = sum( urban_pop ) ) %>%
          completeID( UN_code, iso, country )
        pop_list[[ length( pop_list ) + 1 ]] <<- out  # append to pop_list
        warnings( cat( "Population for ", iso, 
                       " (now dissolved) is generated by summing member countries: ", 
                       unique( df$iso[ df$iso %in% vector_of_iso ] ) ) )
        return( out )
      } else warning( paste0( "Population for ", iso, " cannot be generated" ) )
    }
    
    # extendIndivScenario(): takes df containing two population time series (pop1, pop2
    # -- described below), extends pop1 using pop2's growth, returns completed pop1 series.
    #   pop1: incomplete series, to be extended using pop2 growth rate; assumed to cover
    #         a continuous range of all pop2 years (e.g. 1960-2014 covers a continuous 
    #         range of 1950-2100)
    #   pop2: complete series, to be used as proxy for extending pop1 (see example below)
    #   first_data_year: first year where pop1 is available
    #   last_data_year: last year where pop1 is available
    # EXAMPLE: Say pop1 is available 1960-2014 and pop2 is available 1950-2100, so first_data_year
    # is 1960 and last_data_year is 2014. Then pop1 will be extended to 1950-2100 as follows:
    #   pop1[1959] = pop1[1960] * pop2[1959] / pop2[1960]
    #   pop1[1958] = pop1[1959] * pop2[1958] / pop2[1959]
    #              = pop1[1960] * ( pop2[1959] / pop2[1960] ) * ( pop2[1958] / pop2[1959] )
    #              = pop1[1960] * pop2[1958] / pop2[1960]
    #   pop1[1950] = pop1[1960] * pop2[1950] / pop2[1960]
    #   pop1[2100] = pop1[2014] * pop2[2100] / pop2[2014]
    extendIndivScenario <- function( df, pop1, pop2, first_data_yr, last_data_yr, 
                                     UN_code = NA, iso = NA, country = NA ){
      out <- arrange( df, year )
      for ( i_year in out$year ){
        if ( i_year < first_data_yr ){
          out[ out$year == i_year, pop1 ] <- out[ out$year == first_data_yr, pop1 ] * 
            out[ out$year == i_year, pop2 ] / out[ out$year == first_data_yr, pop2 ]
        }
        if ( i_year > last_data_yr ){
          out[ out$year == i_year, pop1 ] <- out[ out$year == last_data_yr, pop1 ] * 
            out[ out$year == i_year, pop2 ] / out[ out$year == last_data_yr, pop2 ]
        }
      }
      names( out )[ names( out ) == pop1 ] <- "pop"
      out <- out[ names( out ) %in% names( UN_pop ) ]
      out <- completeID( out, UN_code, iso, country )
      return( out )
    }
    
    # extendPop(): operates split-apply-combine of extendIndivScenario() by scenario.
    # Results are appended to pop_list.
    extendPop <- function( df, pop1, pop2, first_data_yr, last_data_yr, 
                           UN_code = NA, iso = NA, country = NA ){
      # Future projection scenarios may not have base pop1 to extend from -- extract 
      # last pop1 data year and bind to all scenarios
      last <- filter( df, scenario == "Estimates" ) %>% 
        filter_( paste0( "!is.na(", pop1, ")" ) ) %>%
        filter( year == max( year ) ) %>% 
        select( -scenario ) %>%
        merge( data.frame( scenario = UN_scenarios_std ), all = T )
      out <- bind_rows( df, last ) %>% unique()
      
      # Now extend pop1 using pop2 growth, by scenario
      out <- ddply( out, .(scenario), function(x){
        extendIndivScenario( x, pop1, pop2, first_data_yr, last_data_yr, 
                             UN_code, iso, country )
      } )
      
      # Remove duplicated last pop1 data year from all scenarios except Estimates
      last_yr <- unique( last$year )[[1]]
      out <- filter( out, scenario == "Estimates" | year != last_yr )
      
      # Append result to pop_list
      pop_list[[ length( pop_list ) + 1 ]] <<- out 
      warning( paste0( pop1, " is only available ", 
                       first_data_yr, "-", last_data_yr, 
                       ". Remaining years are estimated using ", pop2, " growth rate." ) )
      return( out )
    } 
    
# For Kosovo (detached from Serbia in 2008), use WB Kosovo population (1960-2014)
# and Serbia's pop growth to extend the remaining years (1950-1959, 2015-2100)
# Kosovo has no WB urban population data -- assume Serbia's UN urban share
    # Extract Kosovo from WB population, Serbia from UN population, and merge into one df
    kosovo <- filter( WB_pop, country == "Kosovo" ) %>% select( year, pop )
    names( kosovo ) <- c( "year", "kosovo_pop" )
    serbia <- filter( UN_pop, country == "Serbia" ) %>% select( scenario, year, pop, urban_share )
    names( serbia ) <- c( "scenario", "year", "serbia_pop", "urban_share" )
    serbia_kosovo <- merge( serbia, kosovo, all = T ) %>% arrange( scenario, year )
    
    # Extend Kosovo population using Serbia's growth. Results are added to pop_list for 
    # later binding.
    kosovo_new <- extendPop( serbia_kosovo, pop1 = "kosovo_pop", pop2 = "serbia_pop", 
                             first_data_yr = min( WB_pop_years ), last_data_yr = max( WB_pop_years ),
                             country = "Kosovo", iso = "srb (Kosovo)" )

# For csk (dissolved in 1993 into cze and slk) and scg (dissolved in 2006 into srb and mne),
# add population of member countries before dissolution. Results are added to pop_list for later
# binding. The objects csk and scg themselves are not used.
#     csk <- sumPop( UN_pop, c( "cze", "slk" ), UN_code = 200, iso = "csk", 
#                    country = "Czechoslovakia" )
    scg <- sumPop( UN_pop, c( "mne", "srb" ), UN_code = 891, iso = "scg", 
                   country = "Serbia and Montenegro" )
    
# Create master population data (with projections for now-extinct countries)
    pop_master <- ldply( pop_list, rbind.fill ) %>%
      arrange( scenario, iso, year )


# ------------------------------------------------------------------------------
# 4. Extend urban population share to all UN years, using growth in the two edge years
# Compute urban share from urban_pop and pop if necessary
    pop_master$urban_share[ is.na( pop_master$urban_share ) ] <- 
      pop_master$urban_pop[ is.na( pop_master$urban_share ) ] / 
      pop_master$pop[ is.na( pop_master$urban_share ) ]
    pop_master$urban_pop <- NULL
    
# Need to extrapolate urban_share for what years?
    years_needed <- setdiff( UN_pop_years, UN_urban_years )  # 2051-2100

# Routine below is for right (future) extrapolation (extrapolate 2051-2100 urban_share
#   using 2050 urban_share and 2049-2050 growth), which is all that's necessary now. Left
#   (historical) extrapolation is similar -- just add later if necessary.
    # Separate rows with urban_share and rows with no urban_share
    done <- filter( pop_master, !is.na( urban_share ) )
    needed <- filter( pop_master, is.na( urban_share ) )
    
    # Filter out the two edge years
    urban_growth <- filter( done, year >= min( years_needed ) - 2 ) %>%
      select( iso, year, scenario, urban_share ) %>%
      arrange( iso, scenario, year )
    
    # Compute growth of UN urban_share in two edge years for each country
    # Note growth will be NA if both edge years have 0 urban share, in which
    # case make growth 0 to keep urban share at 0 in future years
    urban_growth <- group_by( urban_growth, iso, scenario ) %>%
      mutate( growth = urban_share / lag( urban_share ) ) %>%
      filter( year == min( years_needed ) - 1 )
    urban_growth$growth[ is.na( urban_growth$growth ) ] <- 0
    names( urban_growth ) <- c( "iso", "base_year", "scenario", 
                                "base_urban_share", "growth" )
    
    # Extend urban_share to all UN years, using base year share and growth
    # in the two edge years
    needed <- merge( needed, urban_growth, all.x = T ) %>%
      mutate( urban_share = base_urban_share * growth^( year - base_year ) ) %>%
      select( -base_year, -base_urban_share, -growth )
    
    # If urban_share > 1, bring down to 1
    needed$urban_share[ needed$urban_share > 1 ] <- 1

# Bind original and extended data in one df
    pop_master_ext <- bind_rows( done, needed ) %>%
      arrange( iso, scenario, year )

# Change NAs to blank before writing output
    pop_master_ext[ is.na( pop_master_ext ) ] <- ""
    
# ------------------------------------------------------------------------------
# 5. Write output
    writeData( pop_master_ext, "MED_OUT", "A.UN_pop_master" )
    
# Every script should finish with this line
    logStop()
    
# END